### **Промт: Система автоматического резервного копирования базы данных с интеграцией в экосистему Google**

**Цель:** Разработать отказоустойчивое решение для автоматического резервного копирования реляционной базы данных с хранением бэкапов в личном аккаунте Google Drive и опциональной синхронизацией данных в Google Sheets.

---

**Контекст и задачи:**

1.  **Основной источник данных:** Реляционная база данных **PostgreSQL** (локально на сервере), а не Google Sheets. Google Sheets используется как **дополнительный канал синхронизации** для аналитики и отчетности.
2.  **Ключевое требование:** **Снизить риски потери данных** за счет:
    - Регулярного создания бэкапов по расписанию
    - Хранения копий в облаке (отдельно от источника)
    - Автоматического удаления устаревших бэкапов (политика хранения)
3.  **Авторизация для Google Drive:** Использовать **OAuth 2.0 с refresh token** (через `token.pickle`), так как **сервисные аккаунты не работают** для загрузки в личный Google Drive из-за ограничения `storageQuotaExceeded` (у сервисных аккаунтов отсутствует квота хранения).
4.  **Хранилище бэкапов:** Папка на **личном Google Drive** (не Shared Drive, не Google Cloud Storage), принадлежащая пользователю. Общие диски (Shared Drives) недоступны в личных аккаунтах — требуют подписки Google Workspace.
5.  **Форматы бэкапов:** Поддержка нескольких форматов одновременно: `CSV`, `Excel (.xlsx)`, `JSON` (настраивается через переменную окружения `BACKUP_FORMATS`).
6.  **Обратная связь:** Отправка email-уведомлений через **локальный SMTP-сервер** (порт 25) с детальным отчетом о статусе операции.
7.  **Дополнительно:** Опциональная синхронизация данных из БД в **Google Sheets** для удобства анализа (отдельная функция, не связанная с бэкапом).

---

**Техническая архитектура решения:**

*   **Стек технологий:**
    - Язык: **Python 3.10+**
    - Фреймворк: **Flask** (веб-интерфейс + админ-панель через Flask-Admin)
    - ORM: **SQLAlchemy** для работы с PostgreSQL
    - Аутентификация: **OAuth 2.0** для Google Drive (не сервисный аккаунт!)
    - Библиотеки: `google-auth`, `google-api-python-client`, `pandas`, `openpyxl`, `psycopg2-binary`
*   **Компоненты системы:**
    1.  **DriveService** — управление загрузкой файлов в Google Drive через OAuth 2.0
    2.  **BackupManager** — создание бэкапов в указанных форматах с именем `backup_YYYYMMDD_HHMMSS.{format}`
    3.  **RetentionPolicy** — автоматическое удаление бэкапов старше `BACKUP_RETENTION_DAYS` (по умолчанию 30 дней)
    4.  **EmailService** — отправка отчетов через локальный SMTP-сервер
    5.  **SheetSync** — опциональная синхронизация данных в Google Sheets (отдельный сервис)
*   
Расписание: Системный cron на сервере (не Cloud Scheduler):
# Ежедневный бэкап в 02:00 (логи в директорию проекта)
0 2 * * * cd /var/www/automatic_database_backup && /var/www/automatic_database_backup/venv/bin/python run_backup_cli.py >> /var/www/automatic_database_backup/logs/backup_cron.log 2>&1

Получение токена: python get_token.py 

**Критически важные нюансы (частые ошибки):**

| Проблема | Решение |
|----------|---------|
| ❌ Сервисный аккаунт для личного Drive | ✅ Использовать **OAuth 2.0 + refresh token** через `token.pickle` |
| ❌ Попытка создать папку через сервисный аккаунт | ✅ Папку **должен создать владелец личного аккаунта** и поделиться с сервисным аккаунтом (но лучше использовать OAuth) |
| ❌ Shared Drive в личном аккаунте | ❌ Недоступно — требует Google Workspace ($6/мес) |
| ❌ Отсутствие `DRIVE_BACKUP_FOLDER_ID` в `.env` | ✅ Обязательно указать **статический ID папки** (не искать по имени!) |
| ❌ Удаление `token.pickle` | ❌ Нарушает работу системы — файл содержит долгоживущий refresh token |

---

**Пример сценария работы:**

> «Система ежедневно в 02:00 запускает бэкап локальной базы данных PostgreSQL. Данные экспортируются в три формата: `backup_20260210_020000.csv`, `backup_20260210_020000.xlsx`, `backup_20260210_020000.json`. Все файлы загружаются в папку `Backups` на личном Google Drive пользователя (владелец: `cubinez85@gmail.com`) через OAuth 2.0. Старые бэкапы старше 30 дней автоматически удаляются. На почту `cubinez85@cubinez.ru` приходит отчет с количеством обработанных записей, размером файлов и ссылками на загрузку.»

---

**Ключевые критерии успеха:**
- ✅ Полная автоматизация от запуска до уведомления
- ✅ Надежное хранение в облаке (отдельно от источника)
- ✅ Отказоустойчивость через политику хранения (автоудаление старых копий)
- ✅ Минимизация рисков через правильную авторизацию (OAuth 2.0 вместо сервисного аккаунта)
- ✅ Гибкость конфигурации через `.env` без изменения кода
- ✅ Простота восстановления: любой бэкап доступен по прямой ссылке из письма

---

**Важно:** Для личных аккаунтов Google **OAuth 2.0 — единственный рабочий способ** загрузки файлов через API. Сервисные аккаунты технически невозможны для этой задачи из-за ограничения квоты хранения. Это фундаментальное ограничение платформы, а не недостаток реализации.
